// ==========================[ Includes ]===============================
#include "fifo.h"
// ======================[ Public functions ]===============================
void fifoInit(fifoHandler_t *f, uint8_t *buffer, uint16_t size){
	f->buffer = buffer;
	f->size = size;
	f->head = 0;
	f->tail = 0;
	return;
}

bool fifoPush(fifoHandler_t *f, uint8_t data){
	uint16_t nextHead = (f->head + 1) % f->size;
	if(nextHead == f->tail){
		return false;								//FIFO buffer is full
	}

	f->buffer[f->head] = data;
	f->head = nextHead;
	return true;
}

bool fifoPushArray(fifoHandler_t *f, const uint8_t *data, uint16_t size){
	uint16_t availableSpace = f->size - fifoAvailable(f) - 1;

	//Check if there is enough space
	if(size > availableSpace){
		return false; 								//There isn't enough space
	}

	//Push the values into the fifo buffer
	for(uint16_t i = 0; i < size; i++){
		f->buffer[f->head] = data[i];
		f->head = (f->head + 1) % f->size;
	}
	return true;
}

bool fifoPop(fifoHandler_t *f, uint8_t *data){
	if(f->head == f->tail){
		return false;								//Empty FIFO buffer
	}

	//Return the last element that wasn't read before
	*data = f->buffer[f->tail];
	f->tail = (f->tail + 1) & f->size;
	return true;
}

bool fifoPopArray(fifoHandler_t *f, uint8_t *data, uint16_t size){
	if(size > fifoAvailable(f)){
		return false;								//There aren't enough data
	}

	//Copy the values of the buffer into the data array
	for(uint16_t i = 0; i < size; i++){
		data[i] = f->buffer[f->tail];
		f->tail = (f->tail + 1) % f->size;
	}
	return true;
}


