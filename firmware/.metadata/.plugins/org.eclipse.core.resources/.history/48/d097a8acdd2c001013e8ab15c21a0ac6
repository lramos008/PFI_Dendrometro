// ==========================[ Includes ]===============================
#include "main.h"
#include <stdio.h>
#include "hm10_driver.h"

// ========================[ AT commands ]==============================
#define HM10_CHECK_RESPONSE				"AT"
#define HM10_SET_DEVICE_NAME			"AT+NAME"
#define HM10_SET_BAUDRATE				"AT+BAUD"
#define HM10_CHECK_BAUDRATE				"AT+BAUD?"
#define HM10_CONFIG_ROLE				"AT+ROLE"
#define HM10_SET_ADV_INTERVAL			"AT+ADVI"
#define HM10_SET_ADV_TYPE				"AT+ADTY"
#define HM10_SLEEP						"AT+SLEEP"
#define HM10_RESET						"AT+RESET"
#define HM10_ENABLE_AUTOSLEEP			"AT+PWRM1"
#define HM10_DEFINE_WORK_TYPE			"AT+IMME"
#define HM10_CONFIG_TRANSMISSION_POWER	"AT+POWE"

// ======================[ Private defines ]============================
#define CMD_BUFFER_SIZE	30
#define RESPONSE_BUFFER_SIZE 40
#define HM10_DMA_BUFFER_SIZE 64
#define GLOBAL_TIMEOUT 100
#define ENABLE_CONFIG_FUNCTIONS 0
// ======================[ Extern variables ]===========================
extern UART_HandleTypeDef huart2;
// ======================[ Global variables ]===========================
char response[RESPONSE_BUFFER_SIZE] = {0};
uint8_t HM10DMABuffer[HM10_DMA_BUFFER_SIZE] = {0};
volatile bool receptionCompleteFlag = false;							//Use to know when to process a received command
// ======================[ Private variables ]===========================
static UART_HandleTypeDef *hm10Uart = NULL;
// ======================[ Private functions ]===========================
static HM10Status_t HM10TransmitATCommand(const char *command, char *response, uint16_t maxLength, uint32_t timeout){
	char cmdBuffer[CMD_BUFFER_SIZE];
	int bytesToSend;
	HAL_StatusTypeDef status;

	// Add termination characters to the command
	bytesToSend = snprintf(cmdBuffer, CMD_BUFFER_SIZE, "%s\r\n", command);
	if(bytesToSend < 0) return HM10_ERROR_STRING;

	// Send AT command via UART
	status = HAL_UART_Transmit(hm10Uart, (uint8_t *)cmdBuffer, bytesToSend, timeout);
	if(status == HAL_BUSY) return HM10_ERROR_BUSY;
	else if(status != HAL_OK) return HM10_ERROR_UART;

	//Wait for response
	uint32_t startTime = HAL_GetTick();
	uint16_t index = 0;
	uint8_t receivedCharacter;
	while(HAL_GetTick() - startTime < timeout && index < maxLength - 1){
		status = HAL_UART_Receive(&huart2, &receivedCharacter, 1, 10);			// 10 ms of timeout between each character
		if(status == HAL_OK){
			response[index++] = receivedCharacter;
			if(receivedCharacter == '\n') break;								//End of AT command
		}
	}

	// Add end of string character
	response[index] = '\0';

	//Handle condition if there is no character in reception
	if(index == 0) return HM10_ERROR_TIMEOUT;
	return HM10_OK;
}

static HM10Status_t HM10SendATCheckOK(const char *command){
	HM10Status_t status;
	//Clean response buffer
	memset(response, 0, RESPONSE_BUFFER_SIZE);

	//Send AT command
	status = HM10TransmitATCommand(command, response, RESPONSE_BUFFER_SIZE, GLOBAL_TIMEOUT);

	//Check for errors
	if(status != HM10_OK) return status;														//Possible transmission error
	if(!(response[0] == 'O' && response[1] == 'K')) return HM10_ERROR_AT_COMMAND_RESPONSE;		//Possible error response from HM10
	return HM10_OK;
}



// ======================[ Public functions ]===========================
void HM10Init(UART_HandleTypeDef *huart){
	//Register the used UART
	hm10Uart = huart;

	//Initiate DMA reception
	HAL_UART_Receive_DMA(hm10Uart, HM10DMABuffer, HM10_DMA_BUFFER_SIZE);

	//Enable IDLE line interrupt
	__HAL_UART_ENABLE_IT(hm10Uart, UART_IT_IDLE);
}

void HM10IRQHandler(UART_HandleTypeDef *huart){
	uint16_t receivedBytes;
	if(__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE)){
		//Clear idle flag
		__HAL_UART_CLEAR_IDLEFLAG(huart);

		//Pause DMA
		HAL_UART_DMAStop(huart);

		//Calculate the number of received bytes
		receivedBytes = HM10_DMA_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(huart->hdmarx);

		//Process data
		receptionCompleteFlag = true;

		//Reset DMA
		HAL_UART_Receive_DMA(huart, HM10DMABuffer, HM10_DMA_BUFFER_SIZE);
	}
}


#if DEBUG_FUNCTIONS == 1
/*Funciones usadas durante el debug*/
HM10Status_t HM10CheckBaudrate(HM10Baudrate_t *baudrate){
	HM10Status_t status;
	memset(response, 0, RESPONSE_BUFFER_SIZE);

	//Send AT command
	status = HM10TransmitATCommand(HM10_CHECK_BAUDRATE, response, RESPONSE_BUFFER_SIZE, GLOBAL_TIMEOUT);
	if(status != HM10_OK) return status;

	//Check if the HM10 response is OK
	if(!(response[0] == 'O' && response[1] == 'K')) return HM10_ERROR_AT_COMMAND_RESPONSE;		//Possible error response from HM10

	//If response is OK, extract the baudrate
	*baudrate = (HM10Baudrate_t) (response[7] - '0');
	if(*baudrate < 0 || *baudrate > 8) return HM10_ERROR_AT_COMMAND_RESPONSE;					//Incorrect baudrate
	return HM10_OK;
}

HM10Status_t HM10SetBaudrate(HM10Baudrate_t baudrate){
	char cmdBuffer[CMD_BUFFER_SIZE] = {0};
	//Build AT command
	snprintf(cmdBuffer, CMD_BUFFER_SIZE, "%s%u", HM10_SET_BAUDRATE, baudrate);
	return HM10SendATCheckOK((const char *)cmdBuffer);
}

HM10Status_t HM10SetDeviceName(const char *name){
	char cmdBuffer[CMD_BUFFER_SIZE] = {0};
	snprintf(cmdBuffer, CMD_BUFFER_SIZE, "%s%s", HM10_SET_DEVICE_NAME, name);
	return HM10SendATCheckOK((const char *)cmdBuffer);
}

#endif

HM10Status_t HM10CheckResponse(void){
	return HM10SendATCheckOK(HM10_CHECK_RESPONSE);
}

HM10Status_t HM10ConfigRole(HM10Role_t role){
	char cmdBuffer[CMD_BUFFER_SIZE] = {0};
	//Build AT command
	snprintf(cmdBuffer, CMD_BUFFER_SIZE, "%s%u", HM10_CONFIG_ROLE, role);
	return HM10SendATCheckOK((const char *)cmdBuffer);
}

/*Define si se conecta automaticamente para recibir datos, o espera a un comando AT inicialmente IMME = 0 Auto connect*/
HM10Status_t HM10SetModuleWorkType(HM10WorkType_t workType){
	char cmdBuffer[CMD_BUFFER_SIZE] = {0};
	//Build AT command
	snprintf(cmdBuffer, CMD_BUFFER_SIZE, "%s%u", HM10_DEFINE_WORK_TYPE, workType);
	return HM10SendATCheckOK((const char *)cmdBuffer);
}

HM10Status_t HM10ConfigAdvertisingType(HM10AdvType type){
	char cmdBuffer[CMD_BUFFER_SIZE] = {0};
	//Build AT command
	snprintf(cmdBuffer, CMD_BUFFER_SIZE, "%s%u", HM10_SET_ADV_TYPE, type);
	return HM10SendATCheckOK((const char *)cmdBuffer);
}

HM10Status_t HM10SetAdvertisingInterval(HM10AdvInterval_t interval){
	char cmdBuffer[CMD_BUFFER_SIZE] = {0};
	//Build AT command
	snprintf(cmdBuffer, CMD_BUFFER_SIZE, "%s%X", HM10_SET_ADV_INTERVAL, interval);
	return HM10SendATCheckOK((const char *)cmdBuffer);
}

/*Configura la potencia de transmision (puede reducir el rango)*/
HM10Status_t HM10ConfigTransmissionPower(HM10PowerMode_t powerMode){
	char cmdBuffer[CMD_BUFFER_SIZE] = {0};
	//Build AT command
	snprintf(cmdBuffer, CMD_BUFFER_SIZE, "%s%u", HM10_CONFIG_TRANSMISSION_POWER, powerMode);
	return HM10SendATCheckOK((const char *)cmdBuffer);
}

HM10Status_t HM10EnableAutoSleep(void){
	return HM10SendATCheckOK(HM10_ENABLE_AUTOSLEEP);
}

HM10Status_t HM10ResetModule(void){
	return HM10SendATCheckOK(HM10_RESET);
}

HM10Status_t HM10Send(const uint8_t *data, uint16_t length){
	HAL_StatusTypeDef status;
	status = HAL_UART_Transmit(&huart2, data, length, HAL_MAX_DELAY);
	if(status == HAL_BUSY) return HM10_ERROR_BUSY;
	else if(status != HAL_OK) return HM10_ERROR_UART;
	return HM10_OK;
}

void HM10ClearReceptionBuffer(void){
	memset(HM10DMABuffer, 0, HM10_DMA_BUFFER_SIZE);
}





//bool HM10IsConnected(void){
//	return HAL_GPIO_ReadPin(HM10_STATE_GPIO_Port, HM10_STATE_Pin) == GPIO_PIN_SET;
//}


//void HM10Callback(void){
//	if (__HAL_UART_GET_FLAG(&huart2, UART_FLAG_IDLE)){
//		  __HAL_UART_CLEAR_IDLEFLAG(&huart2);
//
//		  receptionCompleteFlag = true;
//		  HAL_UART_Receive_DMA(&huart2, rxBuffer, RX_BUFFER_SIZE);
//	}
//}



